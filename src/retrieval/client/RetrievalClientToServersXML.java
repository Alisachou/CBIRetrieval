/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package retrieval.client;

import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.log4j.Logger;
import org.jdom.Document;
import retrieval.dist.MessageError;
import retrieval.dist.MessageResults;
import retrieval.dist.MultiServerMessageNBT;
import retrieval.dist.MultiServerMessageResults;
import retrieval.dist.MultiServerMessageSimilarities;
import retrieval.dist.NotValidMessageXMLException;
import retrieval.dist.ResultsSimilarities;
import retrieval.exception.CBIRException;
import retrieval.storage.index.ResultSim;
import retrieval.utils.Chrono;
import retrieval.utils.NetworkUtils;

/**
 * Central server side of Communication class between Central Server and servers
 * with XML message and TCP/IP Socket
 * @author Rollus Loic
 */
public class RetrievalClientToServersXML{

    /**
     * Server list
     */
    private ListServerInformationSocket listsServer;
    /**
     * Logger
     */
    private static Logger logger = Logger.getLogger(RetrievalClientToServersXML.class);


    public int getNumberOfServer() {
        return listsServer.size();
    }
    /**
     * Launch communication class on server
     * @param listsServer List of server
     */
    public RetrievalClientToServersXML(ListServerInformationSocket listsServer) {
        this.listsServer = listsServer;
    }

    /**
     * This function seach similar picture with the help of visualwords
     * generated by Iq (request image).
     * @param visualWords Visual words of Iq
     * @param N Number of patch extracted from Iq
     * @param k Max similar picture from each server
     * @return Max k*S similar pictures and a list of server state
     * @throws InterruptedException Internal error during search
     */
    public ResultsSimilarities searchMultiThread(List<ConcurrentHashMap<String, Long>> visualWords, int N, int k, String[] servers) throws InterruptedException {

        if (logger.isDebugEnabled()) {
            logger.debug("searchMultiThread: N=" + N + " T=" + visualWords.size() + " k=" + k);
            logger.debug("searchMultiThread: build first message...");
        }
        //ask for nbt on each server
        logger.debug("getNBTFromServers");
        MultiServerMessageSimilarities msgNBT = getNBTFromServers(visualWords, N, k,servers);
        //ask for similar pictures on each server thanks to nbt
        logger.debug("getMostSimilarPictureFromServers");
        MultiServerMessageResults msgSimilar[] = getMostSimilarPictureFromServers(msgNBT);
        //filter most similar picture (sort + filter k first)
        logger.debug("sortAndTrimBestResults");
        ResultsSimilarities results = sortAndTrimBestResults(msgSimilar, k);
        //fill the size of each server index (number of picture
        logger.debug("fillSizeOfServer");
        fillSizeOfServer(msgSimilar, results);
        logger.debug("results");
        try {listsServer.closeAll();}catch(Exception e) {logger.warn(e);}
        return results;
    }
    /**
     * Sort similarities for all server reponse
     * @param msg3s All servers reponses
     * @param k Max similar picture for each server (optimisation parameter)
     * @return All servers reponses sorted
     */
    protected List<ResultSim> sortSimilarities(MultiServerMessageResults[] msg3s, int k) {
        //results will have the max size of number of similar picture (k) * number of server
        List<ResultSim> results = new ArrayList<ResultSim>(k * msg3s.length);
        for (int i = 0; i < msg3s.length; i++) {
            if(msg3s[i]!=null) {
                Map<String,List<ResultSim>> allServerSim = msg3s[i].getResults();
            
                Iterator<Entry<String,List<ResultSim>>> it = allServerSim.entrySet().iterator();

                while(it.hasNext()) {
                   Entry<String,List<ResultSim>> entry = it.next();
                   List<ResultSim> sim = entry.getValue();
                   results.addAll(sim);
                }           
            }      
        }
        Collections.sort(results);
        return results;
    }


    protected ResultsSimilarities sortAndTrimBestResults(MultiServerMessageResults msgSimilar[], int k) {
        return new ResultsSimilarities(sortSimilarities(msgSimilar, k),listsServer);
    }

    /**
     * Fill the size of each server and compute total size
     * @param listsServer Server list
     * @param msgSimilar Message with similarities result from server
     * @param results Result object with similar picture and server info
     */
    protected void fillSizeOfServer(ListServerInformationSocket listsServer, MultiServerMessageResults[] msgSimilar, ResultsSimilarities results) {
        for (int i = 0; i < msgSimilar.length; i++) {
            if (msgSimilar[i] != null) {
                long sizeOfIndex = msgSimilar[i].getNumberOfPicturesInIndex();
                results.add((int)sizeOfIndex);
            }
        }
    }

    protected void fillSizeOfServer(MultiServerMessageResults[] msgSimilar, ResultsSimilarities results) {
        for (int i = 0; i < msgSimilar.length; i++) {
            if (msgSimilar[i] != null) {
                long sizeOfIndex = msgSimilar[i].getNumberOfPicturesInIndex();
                results.add((int)sizeOfIndex);
            }
        }
    }

    /**
     * Get all NBT info on each server
     * @param visualWords Visualword to check NBT
     * @param N Number of patch
     * @param k Number of max result
     * @return Message with sum of NBT from each server
     * @throws InterruptedException
     */
    protected MultiServerMessageSimilarities getNBTFromServers(List<ConcurrentHashMap<String, Long>> visualWords, int N, int k, String[] servers) throws InterruptedException {
        Map<String,List<ConcurrentHashMap<String, Long>>> visualWordsMap = new TreeMap<String,List<ConcurrentHashMap<String, Long>>>();
        visualWordsMap.put("#all#", visualWords);

        MultiServerMessageNBT msgVW = new MultiServerMessageNBT(visualWordsMap,servers);
        MultiServerMessageSimilarities msgSimilar = new MultiServerMessageSimilarities(visualWordsMap, N, k,servers);

        List<Integer> serverKeys = listsServer.getKeys();
        ClientAskNbtThread[] threadsNBT = new ClientAskNbtThread[listsServer.size()];
        for (int i = 0; i < serverKeys.size(); i++) {
            Integer serverKey = serverKeys.get(i);
            //if server is OK, try to send message
            threadsNBT[i] = new ClientAskNbtThread(msgVW, msgSimilar, listsServer.get(serverKey));
            threadsNBT[i].start();
            logger.error("searchMultiThread1: ok=" + listsServer.get(serverKey).toString());
        }

        //wait all server similar pictures
        for (int i = 0; i < threadsNBT.length; i++) {
            if (threadsNBT[i] != null) {
                threadsNBT[i].join();
            }
        }
        return msgSimilar;
    }

    /**
     * Get Most Similar Pictures
     * @param msgWithNBT Message with NBT
     * @return Result for each server
     * @throws InterruptedException
     */
    protected MultiServerMessageResults[] getMostSimilarPictureFromServers(MultiServerMessageSimilarities msgWithNBT) throws InterruptedException {
        /*
         * Ask Similarity between visual word from Iq and index of each server
         */
        ClientAskSimilaritiesThread[] threadsSimilar = new ClientAskSimilaritiesThread[listsServer.size()];
        MultiServerMessageResults[] msg3s = new MultiServerMessageResults[listsServer.size()];

        logger.debug("searchMultiThread: compute results");
        List<Integer> serverKeys = listsServer.getKeys();
        for (int i = 0; i < serverKeys.size(); i++) {
            Integer serverKey = serverKeys.get(i);
            //get the results only if server has send NBT...
            if (listsServer.get(serverKey).getState() == ServerInformationSocket.NOERROR) {
                threadsSimilar[i] = new ClientAskSimilaritiesThread(msgWithNBT, msg3s, i, listsServer.get(serverKey));
                threadsSimilar[i].start();
                logger.info("searchMultiThread2: ok=" + i);
            } else {
                logger.error("searchMultiThread2: nok=" + i);
            }
        }

        //Wait each server response
        for (int i = 0; i < threadsSimilar.length; i++) {
            if (threadsSimilar[i] != null) {
                threadsSimilar[i].join();
            }
        }
        return msg3s;
    }

    /**
     * Fill the size of each server and compute total size
     * @param listsServer Server list
     * @param msgSimilar Message with similarities result from server
     * @param results Result object with similar picture and server info
     */
    protected void fillSizeOfServer(MessageResults[] msgSimilar, ResultsSimilarities results) {
        for (int i = 0; i < msgSimilar.length; i++) {
            if (msgSimilar[i] != null) {
                int sizeOfIndex = msgSimilar[i].getNumberOfPicturesInIndex();
                results.add(sizeOfIndex);
                listsServer.get(i).setSizeOfIndex(sizeOfIndex);
            }
        }
    }
}

/**
 * This Thread ask NBT on a specific server
 * @author Rollus Loic
 */
class ClientAskNbtThread extends Thread {

    private MultiServerMessageNBT msgSource;
    private MultiServerMessageSimilarities msgResult;
    private ServerInformationSocket server;
    private static Logger logger = Logger.getLogger(ClientAskNbtThread.class);

    /**
     * Constructor
     * @param msgSource Message with NBT (Source: IN)
     * @param msgResult Message build with similarity (Result: OUT)
     * @param server Server index
     */
    ClientAskNbtThread(
            MultiServerMessageNBT msgSource,
            MultiServerMessageSimilarities msgResult,
            ServerInformationSocket server) {
        this.msgSource = msgSource;
        this.msgResult = msgResult;
        this.server = server;
    }

    @Override
    public void run() {

        try {
            Chrono c = new Chrono();
            server.connect();
            //set max wait for a server
            //write message
            logger.debug("ClientAskNbtThread run nbt: 1 write msg1 to " + server +" " +c.getTime() );

            NetworkUtils.writeXmlToSocket(server.getSocket(), msgSource.toXML());
            //read reponse
            logger.debug("ClientAskNbtThread run nbt: 2 read msg1 from " + server+" " +c.getTime());
            Document msg1xml = NetworkUtils.readXmlFromSocket(server.getSocket());

            logger.debug("ClientAskNbtThread run nbt: 3 read msg1 from " + server+" " +c.getTime());
            //check if error message
            if (MessageError.isErrorMessage(msg1xml)) {
                throw MessageError.getException(msg1xml);
            }
            //otherwise, complete result
            msgResult.addNBT(msg1xml);
            logger.debug("ClientAskNbtThread run nbt: 4 read msg1 from " + server);
        } catch (SocketTimeoutException e) {
            logger.error("run nbt: timeout:" + e);
            server.changeState(ServerInformationSocket.TIMEOUT, e.getMessage());
        } catch (SocketException e) {
            logger.error("run nbt: lost:" + e);
            server.changeState(ServerInformationSocket.LOST, e.getMessage());
        } catch (NotValidMessageXMLException e) {
            logger.error("run nbt: msg:" + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        } catch (CBIRException e) {
            logger.error("run nbt: servor:" + e);
            server.changeState(ServerInformationSocket.SERVERERROR, e.getMessage());
        } catch (Exception e) {
            logger.error("run nbt: undef:" + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        }
    }
}

/**
 * This Thread ask similar pictures on a server
 * @author Rollus Loic
 */
class ClientAskSimilaritiesThread extends Thread {

    private MultiServerMessageSimilarities msgToSend;
    private MultiServerMessageResults[] msgToReceive;
    private ServerInformationSocket server;
    private int numberOfThread;
    private static Logger logger = Logger.getLogger(ClientAskSimilaritiesThread.class);

    ClientAskSimilaritiesThread(MultiServerMessageSimilarities msgToSend, MultiServerMessageResults[] msgToReceive, int numberOfThread, ServerInformationSocket server) {
        this.msgToSend = msgToSend;
        this.msgToReceive = msgToReceive;
        this.server = server;
        this.numberOfThread = numberOfThread;
    }

    @Override
    public void run() {

        try {
            Chrono c = new Chrono();
            //write request
            logger.debug("ClientAskSimilaritiesThread run sim: 1 write message...:"+c.getTime());
            NetworkUtils.writeXmlToSocket(server.getSocket(), msgToSend.toXML());
            //read response
            logger.debug("ClientAskSimilaritiesThread run sim: 2 read response..."+c.getTime());
            Document msg3xml = NetworkUtils.readXmlFromSocket(server.getSocket());
            logger.debug("ClientAskSimilaritiesThread run sim: 3 read response..."+c.getTime());
            //if error message, throw it
            if (MessageError.isErrorMessage(msg3xml)) {
                throw MessageError.getException(msg3xml);
            }
            //else add similarity on array
            msgToReceive[numberOfThread] = new MultiServerMessageResults(msg3xml);
            logger.debug("ClientAskSimilaritiesThread run sim: 4 read response..."+c.getTime());
        } catch (SocketTimeoutException e) {
            logger.error("run sim: timeout " + e);
            server.changeState(ServerInformationSocket.TIMEOUT, e.getMessage());
        } catch (SocketException e) {
            logger.error("run sim: lost " + e);
            server.changeState(ServerInformationSocket.LOST, e.getMessage());
        } catch (CBIRException e) {
            logger.error("run sim: servor " + e);
            server.changeState(ServerInformationSocket.SERVERERROR, e.getMessage());
        } catch (Exception e) {
            logger.error("run sim: undef " + e);
            server.changeState(ServerInformationSocket.UNDEF, e.getMessage());
        }
    }
}